---
title: What is the c++ equivalent of the generator pattern in python?
authors:
- smart_coder
tags:
- python
- knowledge
thumbnail: images/python.png
created_at: 2023-03-17 00:00:00
updated_at: 2023-03-17 00:00:00
tldr: The equivalent C++ to Python generator pattern is the use of the yield keyword to create a coroutine that produces a sequence of values on demand.
---

**Contents**

[TOC]

Section 1: What is the generator pattern in Python?

In Python, the generator pattern is implemented using iterators. An iterator is an object that can be iterated upon, meaning that you can traverse through all the elements of an iterator. A generator is a special type of iterator that does not need to have all its values generated at once. Instead, it generates values on the fly, as you iterate through it.

Section 2: How to implement the generator pattern in C++?

C++ also supports iterators, but it does not have a built-in generator pattern like Python. However, we can implement a similar pattern using C++'s yield keyword and a custom iterator class. Here's an example implementation:

```c++
#include <iostream>
#include <vector>

class Generator {
public:
    Generator(std::vector<int> data) : data(data) {}

    class Iterator {
    public:
        Iterator(std::vector<int>& data, int index) : data(data), index(index) {}

        bool operator!=(const Iterator& other) const {
            return index != other.index;
        }

        int operator*() const {
            return data[index];
        }

        void operator++() {
            index++;
        }

    private:
        std::vector<int>& data;
        int index;
    };

    Iterator begin() {
        return Iterator(data, 0);
    }

    Iterator end() {
        return Iterator(data, data.size());
    }

private:
    std::vector<int> data;
};

Generator numbers(int count) {
    for (int i = 0; i < count; i++) {
        std::cout << "Generating number " << i << std::endl;
        co_yield i;
    }
}

int main() {
    for (int i : numbers(5)) {
        std::cout << i << std::endl;
    }

    return 0;
}
```

In this example, the Generator class takes a vector of integers as input and provides an Iterator class with begin() and end() methods that enable iteration through the vector. The numbers() function is a generator function that uses the co_yield keyword to generate integers on the fly, similar to the yield keyword in Python. Finally, the main() function uses a range-based for loop to iterate through the numbers generated by the generator function. 

Section 3: Limitations of the C++ generator pattern

While this implementation provides a similar pattern to Python's generator, it is less concise and requires more boilerplate code, especially for custom iterator classes. Additionally, the use of the co_yield keyword is a C++20 feature and may not be available in all C++ compilers. 

Section 4: Alternatives to the C++ generator pattern

There are several alternatives to the C++ generator pattern, including libraries such as Boost.Coroutine and P0057R0, a proposal for a generator language feature in C++. These alternatives aim to provide more concise and standardized ways of implementing the generator pattern in C++.
